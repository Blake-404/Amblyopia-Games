<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geologica:wght@100;400;700;900&display=swap" rel="stylesheet">
  </head>

  <body>

    <div id="tetris">
        <div id="status">
            <div id="lvl">Level <span id="level">1</span></div>
            <div id="gameStatus">TEH TRIS</div>
            <div id="points">0</div>
        </div>
        <div id="grid"></div>   
        <div id="gameMarginBottom"></div>     
    </div>


    <style>
        :root {
            --main-red: #d03333;
            --text-blue: #0f275d;
            --text-red: #f0a9a9;
            --light-gray: #ebebeb;
            --col-x-amt: none;
            --col-y-amt: none;
            --cell-size: 20px;
        }

        #lvl { left: 0; }

        #gameStatus { right: 30%; }

        #points { right: 0; }

        #status > div { position: absolute; }

        #status {
            position: relative;
            height: 25px; 
        }

        * {
            font-family: Geologica;
        }

        #tetris {
            width: fit-content;
        }

        .shapeSegment {
            background-color: red ;
            border-color: red !important;
        }

        .placedCell {
            background-color: var(--text-blue);
            border-color: var(--text-blue) !important;
        }

        .grid-item {
            border: solid 0.5px rgb(209, 209, 209);
        }

        .floorCell {
            background-color: rgb(209, 209, 209);
        }

        .wallCell {
            background-color: rgb(209, 209, 209);
        }

        #grid {
            border: solid 0.5px black;
            display: grid;
            grid-column-gap: 0;
            grid-row-gap: 0;
            grid-template-columns: repeat(var(--col-x-amt), minmax(var(--cell-size), var(--cell-size)));
            grid-template-rows: repeat(var(--col-y-amt), minmax(var(--cell-size), var(--cell-size)));
            grid-auto-columns: 20px;
        }
    </style>

    <script>
        // key listeners

        let currentDirection = undefined;

        // css controlling
        let setRootCss = (prop, val) => {
            document.documentElement.style.setProperty(prop, val);
        }

        // find js query 
        let findQuery = (query) => {
            let foundItem = document.querySelectorAll(query)[0];
            return foundItem
        }

        /////////////////////////////////////////////////
        //////-------------- TETRIS ---------------//////
        /////////////////////////////////////////////////

        // grid variables
        let x = 12;
        let y = 21;
        const gridVolume = x * y;

        // status variables
        let gameStatus = true;
        let linesCleared = 0;
        let pointCount = 0;
        let currentLevel = 1;

        // shape variables
        let startCell = (Math.round((x - 1) / 2)) + ",1"
        let currentRoot = startCell;
        let currentShape = undefined;
        let currShapeCoords = [];
        let placedShapeCells = [];        
        let directions = { "left": [-1, 0], "down": [0, +1], "right": [+1, 0] }

        let currRotation = 0;
        let shapeRotations = {
            "z_block":  {
                0:   [[0, +1],  [0, +2], [+1, +2], [+1, +3]],
                90:  [[-1, +2], [0, +1], [0, +2],  [+1, +1]],
                180: [[0, +1],  [0, +2], [+1, +2], [+1, +3]],
                270: [[-1, +2], [0, +1], [0, +2],  [+1, +1]]
            },
            "t_block" :  {
                0:   [[0, +1],  [0, +2],  [+1, +2], [0, +3]], 
                90:  [[-1, +2], [0, +2],  [+1, +2], [0, +3]], 
                180: [[0, +1],  [0, +2],  [-1, +2], [0, +3]], 
                270: [[0, +1],  [-1, +2], [0, +2],  [+1, +2]]
            },     
            "block" :  {
                0:   [[0, +1], [0, +2], [+1, +1], [+1, +2]],
                90:  [[0, +1], [0, +2], [+1, +1], [+1, +2]],
                180: [[0, +1], [0, +2], [+1, +1], [+1, +2]],
                270: [[0, +1], [0, +2], [+1, +1], [+1, +2]]
            },
            "line" :  {
                0:   [[0, +1], [0, +2], [0, +3], [0, +4]], 
                90:  [[-2, +2], [-1, +2], [0, +2], [+1, +2]],
                180: [[0, +1], [0, +2], [0, +3], [0, +4]], 
                270: [[-1, +2], [0, +2], [+1, +2], [+2, +2]]
            },
             "l_block" :  {
                0:   [[0, +1], [0, +2], [0, +3], [+1, +3]],
                90:  [[-1, +3], [-1, +2], [0, +2], [+1, +2]],
                180: [[-1, +1], [0, +1], [0, +2], [0, +3]], 
                270: [[-1, +2], [0, +2], [+1, +2], [+1, +1]]
             }
        }


        // base grid
        let makeGrid = (x, y) => {

            setRootCss('--col-x-amt', x);
            setRootCss('--col-y-amt', y);
            let x_axis = 1;
            let y_axis = 0;
            for (i = 0; i < gridVolume; i++) {
                if (i % x === 0) {
                    x_axis = 0; 
                    y_axis += 1
                }
                x_axis += 1
                // const grid = document.createElement("div");
                const gridItem = document.createElement('div');
                gridItem.setAttribute('id', i);
                let coords = x_axis + "," + y_axis;
                gridItem.setAttribute('data-coords', coords);
                gridItem.setAttribute('class', 'grid-item');
                let text = document.createTextNode('');
                gridItem.appendChild(text);
                let grid = document.getElementById('grid');
                grid.appendChild(gridItem);

                if (y_axis === y) {
                    gridItem.classList.add('floorCell');
                } 
                if (x_axis === 1 || x_axis === x) {
                    gridItem.classList.add('wallCell');
                }
            }
        }

        // create function to split rootCoord string, add/subtract values to x or y, return new coordString, push to current shape array
        let adjCoordStr = (coord, x, y) => {
            let coordArray = coord.split(",");
            let xCoord = Number(coordArray[0]);
            let yCoord = Number(coordArray[1]);
            xCoord += x; yCoord += y;
            let newCoord = String(xCoord + ',' + yCoord)
            return newCoord
        }

        // draw/update board, remove old shape segments, add new shape segments, draw placedShapes coords onto board
        let drawBoard = () => {
            // search for and remove shape segments
            for (let i = 0; i < gridVolume; i++) {
                let gridElem = document.getElementById(i)
                if (gridElem.classList.contains("shapeSegment")) {
                    gridElem.classList.remove("shapeSegment") }
                if (gridElem.classList.contains("placedCell")) {
                    gridElem.classList.remove("placedCell")
                } 
            }

            // add shapeSegment class to coordinates in shape coord array
            for (let i = 0; i < currShapeCoords.length; i++) {
                let shapeCell = findQuery('[data-coords="' + currShapeCoords[i] + '"]')
                shapeCell.classList.add('shapeSegment') 
            }

            // draw placedShapes onto board
            for (let i = 0; i < placedShapeCells.length; i++) {
                placedShapeCells[i].classList.add('placedCell')
            }


            //debug
            if(currentDirection === "left") {
                // console.log('drawboard done')
            }
        }

        // execute game over
        let gameover = () => {
            gameStatus = false;
            document.getElementById('gameStatus').innerHTML = 'GAMEOVER'
        }

        // generate shape from a root coordinate, if shape is not specified, shape with be random
        let generateShape = (rootCoord, shape = undefined) => {

            // get shape 
            let shapeName  = '';
            let shapes = ["z_block", "t_block", "block", "line", "l_block",
                          "z_block", "t_block", "block","l_block",
                          "z_block", "t_block", "block", "l_block",];
            if (shape === "random") { shapeName = shapes[Math.round(Math.random() * 5)] }

            // draw shape coords to array based off shapeName

            if (currentShape === undefined) { 
                if (shapeName === "z_block")  {  for (let i = 0; i < 4; i++) {  currShapeCoords.push( adjCoordStr(rootCoord,  shapeRotations["z_block"][0][i][0],  shapeRotations["z_block"][0][i][1])   )  }  } 
                if (shapeName === "t_block")  {  for (let i = 0; i < 4; i++) {  currShapeCoords.push( adjCoordStr(rootCoord,  shapeRotations["t_block"][0][i][0],  shapeRotations["t_block"][0][i][1])   )  }  }
                if (shapeName === "block")    {  for (let i = 0; i < 4; i++) {  currShapeCoords.push( adjCoordStr(rootCoord,  shapeRotations["block"][0][i][0],    shapeRotations["block"][0][i][1])     )  }  }
                if (shapeName === "line")     {  for (let i = 0; i < 4; i++) {  currShapeCoords.push( adjCoordStr(rootCoord,  shapeRotations["line"][0][i][0],     shapeRotations["line"][0][i][1])      )  }  }
                if (shapeName === "l_block")  {  for (let i = 0; i < 4; i++) {  currShapeCoords.push( adjCoordStr(rootCoord,  shapeRotations["l_block"][0][i][0],  shapeRotations["l_block"][0][i][1])   )  }  }     
                currentShape = shapeName;   
            }

            // (i) go through current shape coordinates     // (j) go through all placedCells and compare coords to current shape coordinates    // if match, gameover()
            for (let i = 0; i < currShapeCoords.length; i++) {
                // console.log(currShapeCoords[i] + " compared to: ")
                for (let j = 0; j < placedShapeCells.length; j++) {
                    if (currShapeCoords[i] === placedShapeCells[j].getAttribute('data-coords')) {
                        gameover();
                    }
                }
            }
        }

        // move shape based off direction array 
        let moveShape = (dir) => {
            for (let i = 0; i < currShapeCoords.length; i++) {
                let newCoord = adjCoordStr(currShapeCoords[i], directions[dir][0], directions[dir][1]);
                currShapeCoords[i] = newCoord;
            }
            let newRoot = '';
            if (dir === "down") {
                newRoot = adjCoordStr(currentRoot, 0, +1)
            } else if (dir === "left") {
                newRoot = adjCoordStr(currentRoot, -1, 0)
            } else if (dir === "right") {
                newRoot = adjCoordStr(currentRoot, +1, 0)
            }
            currentRoot = newRoot;
        }

        // check to see if the next cells are open
        let isNextOpen = (dir) => {
            // find coords to check
            let coordsToCheck = [];
            let isOpen;
            for (let i = 0; i < currShapeCoords.length; i++) {
                let newCoord = adjCoordStr(currShapeCoords[i], directions[dir][0],  directions[dir][1]);
                let shapeCell = findQuery('[data-coords="' + newCoord + '"]');
                if (shapeCell != undefined && shapeCell.classList.contains("shapeSegment") === false) {
                    coordsToCheck.push(shapeCell);
                }
            }
            // check coords in coordsToCheck for an existing cell or out of bounds
            for (let i = 0; i < coordsToCheck.length; i++) {
                // get its data coords attr and split to array
                let coords = coordsToCheck[i].getAttribute("data-coords").split(",");    
                if (dir === 'down') {
                    // check y coord to see if it is on floor level 
                    if (Number(coords[1]) === y) { 
                        isOpen = false
                        break;
                    // check y coord to see if there is a placedCell 
                    } else if ((coordsToCheck[i].classList.contains("placedCell"))) {
                        isOpen = false
                        break;
                    } else if (coords[1] < y) {
                        isOpen = true
                    }
                } else if (dir === 'left' || dir === 'right') {
                    isOpen = true
                    if (coordsToCheck[i].classList.contains("wallCell")) {
                        isOpen = false
                        break;
                    } else if (coordsToCheck[i].classList.contains("placedCell")) { 
                        isOpen = false
                        break;     
                    }
                }
            } 
            if (isOpen === undefined) { isOpen = false }
            // console.log("isNextDone")
            return isOpen
        }

        // after a shape lands, add its coordinates to placedShapes array
        let updatePlaced = () => {
            for (let i = 0; i < currShapeCoords.length; i++) {
                // console.log("test: " + currShapeCoords[i])
                let shapeCell = findQuery('[data-coords="' + currShapeCoords[i] + '"]')
                placedShapeCells.push(shapeCell);
            }
        }

        // reset shape coord array and remove current shape
        let newShape = () => {
            shapeRotation = 0;
            currShapeCoords = [];
            currentShape = undefined;
            currentRoot = startCell;
            fullLines = [];
            cellRowCounts = {};
        }

        let removeLine = (fullLineID) => {

            // go through placed cells and remove lines that have the same y-axis number as whats passed into the function
            let newPlacedArray = [];
            for (let i = 0; i < placedShapeCells.length; i++) {
                // newPlacedArray.push(placedShapeCells[i])
                let coord = placedShapeCells[i].getAttribute('data-coords').split(",")
                if (Number(coord[1]) != Number(fullLineID) ) {
                    newPlacedArray.push(placedShapeCells[i])
                    placedShapeCells[i].classList.remove('placedCell')
                }
            }
            
// NEED TO: make cells drop correctly after line clear
            let newPlacedArray2 = [];
            let cellCounts = {};
            for (let i = 1; i < x; i++) {
                cellCounts[i] = 0;
                // newPlacedArray2.push(newPlacedArray[i]);

                // how to properly fill cleared spaces
                // look at each column,
                
                
                
                
                
                //IN PLACEDCELLSARRAY???????????????????????????????????



                
//                 for (let j = 1; j < y; j++) {
//                     let coordStr = i + "," + j;
//                     let foundItem = findQuery("[data-coords='" + coordStr + "']")
//                     console.log(coordStr)
//                     console.log(foundItem)
//                     //count how many .placedCells are in each column, store data
//                     if (foundItem.classList.contains('grid-item placedCell')) {
//                         if (cellCounts[i]) { cellCounts += 1 }
//                         else if (!cellCounts[i]) { cellCounts[i] = 1 }
// i                    }

//                 }
//                 console.log(cellCounts)
                // console.log(cellCounts)
                // clear placedShapeCells Array
                // go through each column again and add counts from bottom of board, calculating and pushing new coords to placedShapeCells array.




                // let newCoord = adjCoordStr(newPlacedArray[i].getAttribute("data-coords"), 0, Number(fullLineID)); 
                // let foundNode = findQuery("[data-coords='" + newCoord + "']")
                // if (foundNode != undefined && !foundNode.classList.contains('floorCell')) {
                //     newPlacedArray2.push(foundNode);
                // }
            }
            // placedShapeCells = newPlacedArray2;

        }

        let evaluateLevels = () => {
            let linesNeeded = currentLevel * 10
            if (linesCleared === linesNeeded) { currentLevel += 1; }
            let levelStat = document.getElementById('level');
            levelStat.innerHTML = currentLevel;
        }

        let evaluatePoints = (multiplier) => {
            let increment = 100;
            let points = (100 * currentLevel) * multiplier;
            console.log(points)
            pointCount += points;
            let pointStat = document.getElementById('points');
            pointStat.innerHTML = pointCount;
        }

        // go through placed coords and look for patterns to reward points, increase streak, remove filled lines, and move down placed cells after lines are removed
        let evaluatePlaced = () => {
            let placedCells = [];
            // go througgh placedCell dom array and pull coord attr
            for (let i = 0; i < placedShapeCells.length; i++) {
                let coords = placedShapeCells[i].getAttribute('data-coords').split(",")
                placedCells.push(coords)
            }

            let fullLines = 0;
            let cellRowCounts = {};
            // go through placedCells and add to, init value, or indicate fullline, for a given iter
            for (let i = 0; i < placedCells.length; i++) {
                if(cellRowCounts[placedCells[i][1]] && cellRowCounts[placedCells[i][1]] != (x - 2)) {
                    cellRowCounts[placedCells[i][1]] += 1;
                } else {
                    cellRowCounts[placedCells[i][1]] = 1;
                }
                if(cellRowCounts[placedCells[i][1]] === (x - 2)) {

                    // WHAT TO DO UPON FULL LINE
                    
                //   console.log("line " + placedCells[i][1] + " is full! ->" + cellRowCounts[placedCells[i][1]])
                    removeLine(placedCells[i][1]);
                    console.log("REMOVE ONE LINE ?????") //. .... its removing more than one line .... 
                    fullLines += 1;
                    // if( fullLines.length > 0 ) { removeLine(placedCells[i][1]); }
                    // console.log("found line")
                    // fullLines.push(placedCells[i][1])
                }
            }
            console.log(cellRowCounts)
            // if full lines are detected, award points based on current state
            if (fullLines > 0) {
                evaluatePoints(fullLines);
                evaluateLevels();
            }

          // console.log("full lines");
          // console.log(placedCells);
          // console.log(fullLines);
          // console.log(cellRowCounts);
            
        }

        // code to be executed each tick
        let eachTick = () => {
            // depending on if current shape can move or not
            // move currentShape coords downward one
            if (isNextOpen('down')) {
                // moveShape("down");
            } else {
                updatePlaced();
                evaluatePlaced();
                newShape();
            }
        }

        // execute logic based off state of game 
        let gameLogic = () => {
            //start of turn
            // shape generates, check if its intersection with existing, if so, game over
            if (currentShape === undefined)  {
                generateShape(startCell, "random");
            } else if (currentShape != undefined && gameStatus != false) {
                eachTick();
                drawBoard();
            } else if (gameStatus === false) {
                // gameover code
            }
        }

        // game looping with 0.5s ticks
        let gameLoop = () => {

            gameLogic();
            // debug stuff
            // console.log("------------------------- debug")
            // console.log(placedShapeCells)

            // tick delay
            setTimeout(() => {
                i++;
                if (gameStatus) {
                    gameLoop();
                }
            }, 500)
        }
        
        // rotate piece 90 degrees based off shape rotations object, checks to see if would intersect wall and canceles if so
        let rotate = () => {
            if (currentShape != undefined) {
                currRotation = (currRotation += 90) % 360;
                let prevShape = currShapeCoords;
                currShapeCoords = [];
                for (let i = 0; i < 4; i++) {  
                    let newCoord = adjCoordStr(currentRoot,  
                                    shapeRotations[currentShape][currRotation][i][0],  
                                    shapeRotations[currentShape][currRotation][i][1] )
                    if (document.querySelectorAll("[data-coords='" + newCoord + "']")[0].classList.contains('wallCell') ||
                        document.querySelectorAll("[data-coords='" + newCoord + "']")[0].classList.contains('placedCell') ) {
                        currShapeCoords = prevShape
                        break;
                    } else {
                        currShapeCoords.push( newCoord );
                    }
                }
                drawBoard();   
            }
        }

        // initialize user input controls
        let initUser = () => {
            document.addEventListener('keydown', (e) => {

                if (e.code === "ArrowDown") { 
                    currentDirection = "down";
                    moveShape("down");
                    gameLogic();
                    drawBoard();   
                } 

                else if (e.code === "ArrowLeft") { 
                    currentDirection = "left";
                    if (isNextOpen("left")) { moveShape("left") }
                    drawBoard();  
                }

                else if (e.code === "ArrowRight") { 
                    currentDirection = "right";
                    if (isNextOpen("right")) {  moveShape("right") }
                    drawBoard(); 
                }

                else if (e.code === "ArrowUp") {
                    rotate();
                }

            });
        }

        // initiliaze game
        let runGame = () => {
            makeGrid(x, y); 
            initUser();
            gameLoop();
        }

        window.onload = runGame();

    </script>

  </body>
</html>